//! This is the Rust interface for the Tensorflow model `keras_model/q_learning_model1`.
//! That model is generated by the python script `keras_model/create_q_learning_model.py`

use std::fs::File;
use std::io::Read;
use std::path::Path;

use tensorflow::{Graph, ImportGraphDefOptions, Operation, SavedModelBundle, Session, SessionOptions, SessionRunArgs, Tensor};

use crate::app::{FRAME_SIZE_X, FRAME_SIZE_Y};

const KERAS_MODEL_DIR: &str = "keras_model/q_learning_model_1";
const KERAS_MODEL_CHECKPOINT_FILE: &str = "keras_model/q_learning_model_1.ckpt";

/// series of frames to represent world state
pub const WORLD_STATE_NUM_FRAMES: usize = 4;

// 600x800 pixel (grey-scaled), series of `WORLD_STATE_FRAMES` frames
pub const WORLD_STATE_DIMENSION: &[u64] = &[FRAME_SIZE_X as u64, FRAME_SIZE_Y as u64, WORLD_STATE_NUM_FRAMES as u64];

pub const ACTION_SPACE: u8 = 3;
pub const BATCH_SIZE: u64 = 32;


pub struct QLearningTfModel1 {
    pub graph: Graph,
    pub bundle: SavedModelBundle,
    fn_predict_single: FunctionPredictSingle,
    fn_train_model: FunctionTrainModel,
    fn_save_checkpoint: FunctionSaveCheckpoint
}


impl QLearningTfModel1 {
    pub fn init() -> Self {
        // we load the model as a graph from the path it was saved in
        let model_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join(KERAS_MODEL_DIR);
        let mut graph = Graph::new();

        let bundle = SavedModelBundle::load(
            &SessionOptions::new(), &["serve"], &mut graph, model_dir,
        ).expect("Can't load model");

        // Prepare model function access for 'predict_single'
        //
        // One way to get output names via saved_model_cli:
        // saved_model_cli show --dir /path/to/saved-model/ --all
        let f_predict_single_signature = bundle.meta_graph_def().get_signature("predict_single").unwrap();
        let fn_predict_single = FunctionPredictSingle {
            state_input_operation: graph.operation_by_name_required(&f_predict_single_signature.get_input("state").unwrap().name().name).unwrap(),
            output_operation: graph.operation_by_name_required(&f_predict_single_signature.get_output("action").unwrap().name().name).unwrap(),
        };

        // Prepare model function access for 'train_model'
        let f_train_model_signature = bundle.meta_graph_def().get_signature("train_model").unwrap();
        let fn_train_model = FunctionTrainModel {
            state_samples_input_operation: graph.operation_by_name_required(&f_train_model_signature.get_input("state_samples").unwrap().name().name).unwrap(),
            action_samples_input_operation: graph.operation_by_name_required(&f_train_model_signature.get_input("action_samples").unwrap().name().name).unwrap(),
            updated_q_values_input_operation: graph.operation_by_name_required(&f_train_model_signature.get_input("updated_q_values").unwrap().name().name).unwrap(),
            output_operation: graph.operation_by_name_required(&f_train_model_signature.get_output("loss").unwrap().name().name).unwrap(),
        };

        let f_save_checkpoint_signature = bundle.meta_graph_def().get_signature("write_checkpoint").unwrap();
        let fn_save_checkpoint = FunctionSaveCheckpoint {
            path: graph.operation_by_name_required(&f_save_checkpoint_signature.get_input("path").unwrap().name().name).unwrap(),
            output_operation: graph.operation_by_name_required(&f_save_checkpoint_signature.get_output("path").unwrap().name().name).unwrap(),
        };

        QLearningTfModel1 {
            graph,
            bundle,
            fn_predict_single,
            fn_train_model,
            fn_save_checkpoint
        }
    }

    /// Predicts the next action based on the current state.
    ///
    /// # Arguments
    /// * `state` Game state Tensor [FRAME_SIZE_X, FRAME_SIZE_Y, WORLD_STATE_NUM_FRAMES]
    ///
    pub fn predict(
        &self,
        state: Tensor<f32>,
    ) -> u8 {
        self.fn_predict_single.call(&self.bundle.session, state)
    }

    /// Performs a single training step using a a batch of data.
    /// Returns the model's loss
    ///
    /// # Arguments
    /// * `state_samples` Tensor [BATCH_SIZE, FRAME_SIZE_X, FRAME_SIZE_Y, WORLD_STATE_NUM_FRAMES]
    /// * `action_samples` Tensor [BATCH_SIZE, 1]
    /// * `updated_q_values` Tensor [BATCH_SIZE, 1]
    ///
    pub fn train(
        &self,
        state_samples: Tensor<f32>,
        action_samples: Tensor<i8>,
        updated_q_values: Tensor<f32>,
    ) -> f32 {
        self.fn_train_model.call(&self.bundle.session, state_samples, action_samples, updated_q_values)
    }

    pub fn save_checkpoint(
        &self,
        path: &str
    ) -> String {
        self.fn_save_checkpoint.call(&self.bundle.session, path)
    }
}


struct FunctionPredictSingle {
    state_input_operation: Operation,
    output_operation: Operation,
}

impl FunctionPredictSingle {
    pub fn call(
        &self,
        session: &Session,
        state: Tensor<f32>,
    ) -> u8 {
        // run the computation
        // The values will be fed to and retrieved from the model with this
        let mut args = SessionRunArgs::new();
        args.add_feed(&self.state_input_operation, 0, &state);
        // Fetch result from graph
        let out = args.request_fetch(&self.output_operation, 0);

        session
            .run(&mut args)
            .expect("Error occurred during 'predict_single' calculations");

        // The result will now be stored in the SessionRunArgs object. All thatâ€™s left is to retrieve it.
        // Here we take the value at index zero simply because there is only one value present.
        // in case of train this is the loss
        // (in case of pred it is a prediction value)
        let result: i64 = args.fetch(out).unwrap()[0];
        assert!((0_i64..2).contains(&result));
        result as u8
    }
}

struct FunctionTrainModel {
    state_samples_input_operation: Operation,
    action_samples_input_operation: Operation,
    updated_q_values_input_operation: Operation,
    output_operation: Operation,
}

impl FunctionTrainModel {
    pub fn call(
        &self,
        session: &Session,
        state_samples: Tensor<f32>,
        action_samples: Tensor<i8>,
        updated_q_values: Tensor<f32>,
    ) -> f32 {
        let mut args = SessionRunArgs::new();
        args.add_feed(&self.state_samples_input_operation, 0, &state_samples);
        args.add_feed(&self.action_samples_input_operation, 0, &action_samples);
        args.add_feed(&self.updated_q_values_input_operation, 0, &updated_q_values);

        let out = args.request_fetch(&self.output_operation, 0);

        session.run(&mut args)
            .expect("Error occurred during 'train_model' calculations");
        args.fetch(out).unwrap()[0]
    }
}

struct FunctionSaveCheckpoint {
    path: Operation,
    output_operation: Operation,
}

impl FunctionSaveCheckpoint {
    pub fn call(
        &self,
        session: &Session,
        path: &str,
    ) -> String {
        let path = Tensor::from(String::from(path));
        let mut args = SessionRunArgs::new();
        args.add_feed(&self.path, 0, &path);
        let out = args.request_fetch(&self.output_operation, 0);

        session.run(&mut args)
            .expect("Error occurred during 'save_checkpoint' call");
        args.fetch::<String>(out).unwrap()[0].clone()
    }
}

#[cfg(test)]
mod test {
    use std::error::Error;
    use std::fs::File;
    use std::io::Read;
    use std::path::Path;

    use itertools::Itertools;
    use tensorflow::{Graph, ImportGraphDefOptions, Session, SessionOptions, SessionRunArgs, Tensor};

    use crate::ai::q_learning_tf_model1::{BATCH_SIZE, KERAS_MODEL_CHECKPOINT_FILE, KERAS_MODEL_DIR, QLearningTfModel1, WORLD_STATE_NUM_FRAMES};
    use crate::app::{FRAME_SIZE_X, FRAME_SIZE_Y};

    #[test]
    fn test_load_model() {
        QLearningTfModel1::init();
    }

    #[test]
    fn test_predict() {
        let model = QLearningTfModel1::init();
        let state = Tensor::new(&[FRAME_SIZE_X as u64, FRAME_SIZE_Y as u64, WORLD_STATE_NUM_FRAMES as u64]);
        model.predict(state);
    }

    #[test]
    fn test_train() {
        let model = QLearningTfModel1::init();
        let state_samples = Tensor::new(&[BATCH_SIZE, FRAME_SIZE_X as u64, FRAME_SIZE_Y as u64, WORLD_STATE_NUM_FRAMES as u64]);
        let action_samples = Tensor::new(&[BATCH_SIZE, 1]);
        let updated_q_values = Tensor::new(&[BATCH_SIZE, 1]);

        let _loss = model.train(state_samples, action_samples, updated_q_values);
    }

    #[test]
    fn get_functions() {
        let model = QLearningTfModel1::init();

        log::info!("functions:");
        for f in &model.graph.get_functions().unwrap() {
            log::info!("{}", f.get_name().unwrap_or("n/a".to_string()));
        }

        log::info!("signatures: {}",
            model.bundle.meta_graph_def().signatures().keys().join(","));
    }

    #[test]
    fn test_save_and_load_model_ckpt() -> Result<(), Box<dyn Error>> {
        let model = QLearningTfModel1::init();
        let path = model.save_checkpoint(KERAS_MODEL_CHECKPOINT_FILE);
        log::debug!("{}", path);

        Ok(())
    }
}
